// Self Parser
// Stage 0. Preprocessing (주석 제거)
// Stage 1.


Text "int a;  // ㅇㄴㄻㅇ냠 " => [Text "int" | Whitespace | Text "a;" | Whitespace | Comment]

// stage 설정, 주석 제거 하고 다음 스테이지로 넘겨야 되는
stage Stage0
{
}


// keywords
NAME = r"\w[\d\w]+"
EQUAL = "="
SEMICOLON = ";"
DIGIT = "\d+"

// Expression
Exp
{
    // Const Value
    Const
    {
        IntValue(DIGIT d) { d }
        StringValue(STRING s) { s }
        BoolValue(BOOL b) { b }
    }

    Var(NAME name) { name }

    FuncCall(NAME name, Exp[] exps)
    {
        name LPAREN (exps (COMMA exps)*)? RPAREN
    }

    // bypass
    (Exp e) { LPAREN e RPAREN }

    // i++, i--
    // ++i, --i
    // -i
    // ~i
    PrefixInc(LValue lv) { PLUSPLUS lv }
    PrefixDec(LValue lv) { MINUSMINUS lv }
    PostfixInc(LValue lv) { lv PLUSPLUS }
    PostfixInc(LValue lv) { lv MINUSMINUS }

    UnaryMinus(Exp e) { MINUS e }
    UnaryNeg(Exp e) { TILDE e }

    // Assignment
    Assign(LValue lv, Exp e) { lv EQUAL e }
    AssignAdd(LValue lv, Exp e) { lv PLUSEQUAL e }
    AssignSub(LValue lv, Exp e) { lv MINUSEQUAL e }
    AssignMul(LValue lv, Exp e) { lv STAREQUAL e }
    AssignDiv(LValue lv, Exp e) { lv SLASHEQUAL e }
    AssignAnd(LValue lv, Exp e) { lv AMPEQUAL e }
    AssignOr(LValue lv, Exp e) { lv BAREQUAL e }

    // lv => x, x[3], x.a   

    // ||
    // &&    
    // == !=
    // < <= > >=
    // + -
    // * /
    [
        LogicalOrExp(Exp e1, Exp e2) { e1 BARBAR e2 }

        LogicalAndExp(Exp e1, Exp e2) { e1 AMPAMP e2 }

        {
            Equal(Exp e1, Exp e2) { e1 EQUALEQUAL e2 } 
            NotEqual(Exp e1, Exp e2) { e1 EXCLEQUAL e2 }
        }

        {
            Less(Exp e1, Exp e2) { e1 LESS e2 }
            LessEqual(Exp e1, Exp e2) { e1 LESSEQUAL e2 }
            Greater(Exp e1, Exp e2) { e1 GREATER e2 }
            GreaterEqual(Exp e1, Exp e2) { e1 GREATEREQUAL e2 }
        }
    
        {
            PlusExp(Exp e1, Exp e2) { e1 PLUS e2 }
            MinusExp(Exp e1, Exp e2) { e1 MINUS e2 }
        }

        {
            MulExp(Exp e1, Exp e2) { e1 STAR e2 }
            DivExp(Exp e1, Exp e2) { e1 SLASH e2 }
        }
    ]
}

VarNameAndExp(NAME name, Exp exp)
{
    name (EQUAL exp)?
}

// 변수 선언
// int i = 2, j = 7;
VarDecls(NAME typeName, VarNameAndExp[] nameAndExps)
{
    typeName nameAndExps (COMMA nameAndExps)* SEMICOLON
}

FuncDecl(NAME retType, NAME funcName, TypeAndName[] typeAndNames, BlockStatement body)
{
    retType funcName LPAREN (typeAndNames (COMMA typeAndNames)*)? RPAREN body
}

// { }로 감싸져 있는 Statement
Statement
{
    BlockStatement(Statement[] stmts) { LBRACE (stmts SEMICOLON)* RBRACE }

    VarDeclStatement(NAME typeName, VarNameAndExp[] nameAndExps) { VarDecls(typeName, nameAndExps) SEMICOLON }

    ReturnStatement(Exp exp) { RETURN exp? SEMICOLON }

    BreakStatement() { BREAK SEMICOLON }

    ContinueStatement() { CONTINUE SEMICOLON }

    BlankStatement() { SEMICOLON }

    IfStatement(Exp exp, Statement body) { IF LPAREN exp RPAREN body }

    IfElseStatement(Exp exp, Statement ifStmt, Statement elseStmt)
    {
        IF LPAREN exp RPAREN ifStmt ELSE elseStmt
    }

    WhileStatement(Exp exp, Statement body)
    {
        WHILE LPAREN exp RPAREN body
    }

    DoWhileStatement(BlockStatment body)
    {
        DO body WHILE LPAREN exp RPAREN SEMICOLON
    }
}

// 파일 단위 모듈을 가리킵니다.
Module(VarDecls[] varDecls, FuncDecl[] funcDecls)
{
    (varDecls | funcDecls)*
}
